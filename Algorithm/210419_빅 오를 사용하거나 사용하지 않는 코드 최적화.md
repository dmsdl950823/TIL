- [빅 오를 사용하거나 사용하지 않는 코드 최적화](#빅-오를-사용하거나-사용하지-않는-코드-최적화)
	- [선택 정렬](#선택-정렬)
	- [선택 정렬 구현](#선택-정렬-구현)
	- [선택 정렬의 효율성](#선택-정렬의-효율성)
	- [상수 무시하기](#상수-무시하기)
	- [빅 오의 역할](#빅-오의-역할)

# 빅 오를 사용하거나 사용하지 않는 코드 최적화

빅 오가 유일하게 알고리즘 속도를 측정해주는 도구는 아닙니다. 실제로 빅 오 표기법에서는 두 경쟁 알고리즘이 확연히 다름에도 불구하고 정확히 같은 방식으로 표현하기도 합니다. 그저 표기법일 뿐입니다.

이 장에서는 효율성이 같아 **보이는** 두 알고리즘을 구별해 내서 더 빠른 알고리즘을 고르는 법을 배웁니다.

## 선택 정렬

이전 장 에서는 효율성이 `O(N²)` 인 데이터 정렬 알고리즘으로 *[버블 정렬](./210419_빅%20오로%20코드%20속도%20올리기.md/#버블-정렬)* 을 확인했지만, 이 장에서는 ***선택 정렬*** (selection sort) 라는 또 다른 정렬 알고리즘을 알아보고, 버블정렬과의 효율성을 비교해볼 것입니다.

선택 정렬은 다음과 같은 단계를 거칩니다.

1. 한 셀씩(왼쪽 -> 오른쪽 방향) 이동하면서 현재까지 가장 작은 값을 변수에 저장합니다.
  > 배열의 각 셀을 왼쪽 -> 오른쪽 방향으로 확인하면서, 어떤 값이 최솟값인지 결정합니다.
	> 변수에 들어있는 값 보다 작은 값이 들어있는 셀을 만나면 변수가 새 인덱스를 가리키도록 값을 대체합니다.

2. 이제 최솟값이 어느 인덱스에 들어있는지 알았으므로, 그 *인덱스의 값* 과 패스스루를 처음 시작했을 때의 값을 교환합니다.
  > 패스스루를 시작했을 때 인덱스 ::
	> 
	> 첫 패스스루 일때는 0, 두번째 패스스루일때는 1, 세번째 패스스루는 2 ...

3. 데이터가 모두 정렬될 때 까지 1, 2 단계를 반복합니다.

## 선택 정렬 구현

``` js
	/**
	 * 선택 정렬 구현
	 * @param {Array} array 
	 */
	function solution(array) {
		// 선택 정렬의 각 패스 스루에 해당하는 바깥 루프
		for (let i = 0; i < array.length - 1; i++) {
			let minIndex = i // 현재까지의 최솟값이 들어있는 index 저장

			for (let j = i + 1; j < array.length; j++) {
				if (array[j] < array[minIndex]) {
					minIndex = j // 최솟값 과 현재 값을 비교하고, 현재 값이 더 작다면 현재 최솟값에 저장
				}
				// 안쪽 루프가 종료될 때 아직 정렬되지 않은 값 중 최솟값의 인덱스가 정해집니다.
			}

			// 최솟값이 이미 올바른 위치(i)에 있는지 확인
			// 올바른 위치가 아니라면 '최솟값'과 '최솟값이 있어야할 자리에있는 수' 를 교환한다
			if (i !== minIndex) {
				let temp = array[i]
				array[i] = array[minIndex]
				array[minIndex] = temp
			}
		}

		return array
	}

	let nums = [4, 2, 7, 1, 3]
	solution(nums) // [1, 2, 3, 4, 7]
```

## 선택 정렬의 효율성

선택 정렬은 비교, 교환 단계를 포함하는데, 각 패스스루 내에서 원소를 현재까지 찾은 최솟값과 비교하고, 최솟값을 올바른 위치에 있는 수와 교환합니다.

| 패스스루 번호 | 비교 횟수 |
| ------------- | --------- |
| 1             | 4 번      |
| 2             | 3 번      |
| 3             | 2 번      |
| 4             | 1 번      |

따라서 총 4 + 3 + 2 + 1 = 10 번의 *비교*를 합니다.

그러나 교환은, **한 패스스루당 최대 한 번** 일어납니다. 각 패스스루마다 최솟값이 이미 올바른 위치에 있느냐에 따라 교환을 안 하거나 교환을 한 번 하기 때문입니다. 여기서도 배열이 역순으로 정렬된 최악의 시나리오에서는 버블 정렬과 달리 비교할 때마다 **빠짐없이** 교환을 한 번 해야합니다.

| N 개의 원소 | 버블 정렬에서 최대 단계수 | 선택 정렬에서 최대 단계 수       |
| ----------- | ------------------------- | -------------------------------- |
| 5           | 20                        | 14 (10 번 비교 + 4 번 교환)      |
| 10          | 90                        | 54 (45 번 비교 + 9 번 교환)      |
| 20          | 380                       | 199 (180 번 비교 + 19 번 교환)   |
| 40          | 1560                      | 819 (780 번 비교 + 39 번 교환)   |
| 80          | 6320                      | 3239 (3160 번 비교 + 79 번 교환) |

표와 같이 선택 정렬은 버블정렬보다 단계 수가 반 정도 적으므로, **선택 정렬이 두 배 더 빠릅니다.**

## 상수 무시하기

앞의 버블정렬 vs 선택 정렬의 단계 수를 비교했을때 선택정렬이 두 배 더 성능이 좋지만, **빅 오 표기법에서는 선택 정렬과 버블 정렬을 정확히 같은 방식으로 설명**합니다.

빅 오 표기법은 데이터 원소 수에 비례해 얼마나 많은 단계 수가 필요한가를 표기한 것입니다.

이러한 관점에서 선택 정렬의 단계 수가 약 `O(N² / 2)` 정도로 설명하면 좋겠지만, 선택 정렬을 빅 오로 표현하면 버블 정렬과 똑같이 `O(N²)` 입니다.

```
	빅 오 표기법은 상수를 무시한다
```

빅 오 표기법은 다시말해 **지수가 아닌 수는 포함하지 않는다** 는 것을 수학적으로 표현한 문장이기 때문입니다.

`O(N² / 2)` 는 `O(N²)` 로, `O(2N)` 은 `O(N)` 으로, `O(N / 2)` 도 `O(N)` 으로, `O(100N)` 도 `O(N)` 으로 표기됩니다.

## 빅 오의 역할
