- [빅 오를 사용하거나 사용하지 않는 코드 최적화](#빅-오를-사용하거나-사용하지-않는-코드-최적화)
	- [선택 정렬](#선택-정렬)
	- [선택 정렬 구현](#선택-정렬-구현)
	- [선택 정렬의 효율성](#선택-정렬의-효율성)
	- [상수 무시하기](#상수-무시하기)
	- [빅 오의 역할](#빅-오의-역할)
	- [실제 예제](#실제-예제)
	- [마무리](#마무리)

# 빅 오를 사용하거나 사용하지 않는 코드 최적화

빅 오가 유일하게 알고리즘 속도를 측정해주는 도구는 아닙니다. 실제로 빅 오 표기법에서는 두 경쟁 알고리즘이 확연히 다름에도 불구하고 정확히 같은 방식으로 표현하기도 합니다. 그저 표기법일 뿐입니다.

이 장에서는 효율성이 같아 **보이는** 두 알고리즘을 구별해 내서 더 빠른 알고리즘을 고르는 법을 배웁니다.

## 선택 정렬

이전 장 에서는 효율성이 `O(N²)` 인 데이터 정렬 알고리즘으로 *[버블 정렬](./210419_빅%20오로%20코드%20속도%20올리기.md/#버블-정렬)* 을 확인했지만, 이 장에서는 ***선택 정렬*** (selection sort) 라는 또 다른 정렬 알고리즘을 알아보고, 버블정렬과의 효율성을 비교해볼 것입니다.

선택 정렬은 다음과 같은 단계를 거칩니다.

1. 한 셀씩(왼쪽 -> 오른쪽 방향) 이동하면서 현재까지 가장 작은 값을 변수에 저장합니다.
  > 배열의 각 셀을 왼쪽 -> 오른쪽 방향으로 확인하면서, 어떤 값이 최솟값인지 결정합니다.
	> 변수에 들어있는 값 보다 작은 값이 들어있는 셀을 만나면 변수가 새 인덱스를 가리키도록 값을 대체합니다.

2. 이제 최솟값이 어느 인덱스에 들어있는지 알았으므로, 그 *인덱스의 값* 과 패스스루를 처음 시작했을 때의 값을 교환합니다.
  > 패스스루를 시작했을 때 인덱스 ::
	> 
	> 첫 패스스루 일때는 0, 두번째 패스스루일때는 1, 세번째 패스스루는 2 ...

3. 데이터가 모두 정렬될 때 까지 1, 2 단계를 반복합니다.

## 선택 정렬 구현

``` js
	/**
	 * 선택 정렬 구현
	 * @param {Array} array 
	 */
	function solution(array) {
		// 선택 정렬의 각 패스 스루에 해당하는 바깥 루프
		for (let i = 0; i < array.length - 1; i++) {
			let minIndex = i // 현재까지의 최솟값이 들어있는 index 저장

			for (let j = i + 1; j < array.length; j++) {
				if (array[j] < array[minIndex]) {
					minIndex = j // 최솟값 과 현재 값을 비교하고, 현재 값이 더 작다면 현재 최솟값에 저장
				}
				// 안쪽 루프가 종료될 때 아직 정렬되지 않은 값 중 최솟값의 인덱스가 정해집니다.
			}

			// 최솟값이 이미 올바른 위치(i)에 있는지 확인
			// 올바른 위치가 아니라면 '최솟값'과 '최솟값이 있어야할 자리에있는 수' 를 교환한다
			if (i !== minIndex) {
				let temp = array[i]
				array[i] = array[minIndex]
				array[minIndex] = temp
			}
		}

		return array
	}

	let nums = [4, 2, 7, 1, 3]
	solution(nums) // [1, 2, 3, 4, 7]
```

## 선택 정렬의 효율성

선택 정렬은 비교, 교환 단계를 포함하는데, 각 패스스루 내에서 원소를 현재까지 찾은 최솟값과 비교하고, 최솟값을 올바른 위치에 있는 수와 교환합니다.

| 패스스루 번호 | 비교 횟수 |
| ------------- | --------- |
| 1             | 4 번      |
| 2             | 3 번      |
| 3             | 2 번      |
| 4             | 1 번      |

따라서 총 4 + 3 + 2 + 1 = 10 번의 *비교*를 합니다.

그러나 교환은, **한 패스스루당 최대 한 번** 일어납니다. 각 패스스루마다 최솟값이 이미 올바른 위치에 있느냐에 따라 교환을 안 하거나 교환을 한 번 하기 때문입니다. 여기서도 배열이 역순으로 정렬된 최악의 시나리오에서는 버블 정렬과 달리 비교할 때마다 **빠짐없이** 교환을 한 번 해야합니다.

| N 개의 원소 | 버블 정렬에서 최대 단계수 | 선택 정렬에서 최대 단계 수       |
| ----------- | ------------------------- | -------------------------------- |
| 5           | 20                        | 14 (10 번 비교 + 4 번 교환)      |
| 10          | 90                        | 54 (45 번 비교 + 9 번 교환)      |
| 20          | 380                       | 199 (180 번 비교 + 19 번 교환)   |
| 40          | 1560                      | 819 (780 번 비교 + 39 번 교환)   |
| 80          | 6320                      | 3239 (3160 번 비교 + 79 번 교환) |

표와 같이 선택 정렬은 버블정렬보다 단계 수가 반 정도 적으므로, **선택 정렬이 두 배 더 빠릅니다.**

## 상수 무시하기

앞의 버블정렬 vs 선택 정렬의 단계 수를 비교했을때 선택정렬이 두 배 더 성능이 좋지만, **빅 오 표기법에서는 선택 정렬과 버블 정렬을 정확히 같은 방식으로 설명**합니다.

빅 오 표기법은 데이터 원소 수에 비례해 얼마나 많은 단계 수가 필요한가를 표기한 것입니다.

이러한 관점에서 선택 정렬의 단계 수가 약 `O(N² / 2)` 정도로 설명하면 좋겠지만, 선택 정렬을 빅 오로 표현하면 버블 정렬과 똑같이 `O(N²)` 입니다.

```
	빅 오 표기법은 상수를 무시한다
```

빅 오 표기법은 다시말해 **지수가 아닌 수는 포함하지 않는다** 는 것을 수학적으로 표현한 문장이기 때문입니다.

`O(N² / 2)` 는 `O(N²)` 로, `O(2N)` 은 `O(N)` 으로, `O(N / 2)` 도 `O(N)` 으로, `O(100N)` 도 `O(N)` 으로 표기됩니다.

## 빅 오의 역할


<img src="https://codersite.dev/assets/images/bigONotation-2.jpg" width=500>

> 어떤 크기의 데이터에 대해서는 `O(N²)` 이  `O(100N)` 보다는 빠르지만, 특정 시점을 지나면서 `O(100N)` 이 더 빨라지고 이후로도 계속 더 빠릅니다.

이것이 빅 오가 상수를 무시하는 이유입니다. 빅 오는 **특정 시점**부터 어떤 유형이 다른 유형보다 속도가 빨라지고 이후로도 계속해서 더 빠른 경우 두 유형을 다르게 분리하려 합니다.

버블 정렬과 선택 정렬은 둘다 `O(N²)` 이지만 어쨋든 버블 정렬은 선택 정렬보다 두 배 느립니다.
마찬가지로 `O(log N)` 알고리즘이 `O(2*log N)` 라고 해도 `O(log N)` 이 `O(N)` 보다 항상 빠릅니다.

여기서 중요한 부분은, **두 알고리즘이 같은 분류에 속하더라도 반드시 두 알고리즘의 처리 속도가 같지 않다**는 것 입니다. 
따라서 빅 오에서 **다른 분류**에 속하는 알고리즘을 대조할 경우 빅 오가 완벽한 도구지만, **같은 분류** 에 속하는 두 알고리즘이라면 어떤 알고리즘이 더 빠른지를 알기 위해 더 분석해야합니다.


## 실제 예제

아래는 두 원소마다 하나 걸러 하나를 뽑아 새로운 배열을 생성하는 코드입니다.

``` js
	function everyOther (array) {
		const result = []
		array.forEach((element, idx) => {
			if (!(idx % 2)) result.push(element)
		})
		return result
	}

	const array = [54, 21, 34, 15, 19, 8]
	everyOther(array) // [ 54, 34, 19 ]
```
> 이 코드에서 필요한 단계 수를 분석해보면, 배열을 순회는 N 번, 두 원소에서 한 번 씩만 삽입하므로 N / 2 번 입니다.
> 엄밀히 말하면 `O(N + (N / 2)) = O(1.5N)` 이지만 빅 오 표기법은 상수를 무시하므로 이 알고리즘은 `O(N)` 입니다.

``` js
	function everyOther (array) {
		const result = []
		let idx = 0

		while (idx < array.length) {
			result.push(array[idx])
			idx += 2
		}
		return result
	}

	const array = [54, 21, 34, 15, 19, 8]
	everyOther(array) // [ 54, 34, 19 ]
```
> 각 원소를 하나씩 확인하는 대신 `while` 루프를 활용해 건너 뛰면서 읽습니다.  
> 첫 번째 구현이 1.5 단계를 수행했지만, 두 번째 구현은 N 단계만 수행하므로 두 번째 구현이 훨씬 빠릅니다.
> 
> 첫 번째 구현이 더 자연스럽지만 대량의 데이터를 처리할때는 의미있는 성능 향상을 위해 두 번째 구현을 고려할 수 있습니다.


## 마무리

*선택정렬*과 *버블정렬*이 어떻게 효율성의 측면에서 다른지 확인해 보았습니다.

빅 오는 완벽한 도구는 아니며, 빅 오를 사용해 알고리즘이 대체로 얼마나 효율적인지 알 수 있었고, 빅 오에서 같은 부류에 속하는 두 알고리즘도 비교하는 방법도 알게되었습니다.