- [해시 테이블](#해시-테이블)
	- [해시 함수로 해싱](#해시-함수로-해싱)
	- [해시 함수 사용 예제](#해시-함수-사용-예제)
	- [충돌 해결 - 분리 연결법](#충돌-해결---분리-연결법)
	- [충돌 조정](#충돌-조정)
	- [실제 예제](#실제-예제)


# 해시 테이블

대부분의 프로그래밍 언어는 *해시 테이블* (hash table) 이라는 자료 구조를 포함하며, **빠른 읽기** 라는 능력을 가지고 있습니다.

해시테이블은, *해시*, *해시 맵*, *딕셔너리*, *연관 배열* 등 다양한 언어에서 다양한 이름으로 불립니다.

``` ruby
	menu = {
		"french fries" => 0.75,
		"hamberger" => 2.5,
		"hot dog" => 1.5,
		"soda" => 0.6
	}
```

해시 테이블은 **키 - 값 쌍으로 이루어진 리스트**입니다. `french fires` 는 **키**이며, 값을 가지고 있습니다.
해시 테이블에서 키와 값은 서로 중요한 관계를 가집니다.

해시 테이블의 각 룩업은 딱 한 단계만 걸리므로 평균적으로 효율성이 `O(1)` 입니다.

## 해시 함수로 해싱

비밀 코드를 만든다고 가정하자.

```  
	A = 1    
	B = 2    
	c = 3    
	d = 4 ... 
```

|     | 변환된 값 |
| --- | --------- |
| ACE | 135       |
| CAB | 312       |
| DAB | 412       |
| BAD | 214 ...   |

문자를 가져와 숫자로 변환하는 이러한 과정을 **해싱**이라 부릅니다. 또한, 글자를 특정 숫자로 변환하는데 사용한 코드를 **해시 함수** 라고 부릅니다.

이 밖에 해시 함수는 많은데, *각 문자에 해당하는 숫자를 가져와 모든 수를 합쳐서 반환하는 방법*도 있습니다.

BAD 를 예로 들면,

> 1. 먼저 BAD 를 214 로 변환합니다.
> 2. 각 숫자를 가져와 합칩니다. (2 + 1 + 4 = 7)

또 다른 해시 함수예제로는 *문자에 해당하는 모든 수를 곱해서 반환* 하는 방법입니다.

> 1. 먼저 BAD 를 214 로 변환합니다.
> 2. 각 숫자를 가져와 곱합니다 (2 * 1 * 4 = 8)

실제 쓰이는 해시 함수는 이보다 더 복잡합니다.

------

해시 함수가 유효하려면 딱 한가지 기준을 충족해야하는데,

* 동일한 문자열을 해시 함수에 적용할 때마다 **항상 동일한 숫자로 변환**해야합니다.
* 반환하는 결과가 일관되지 않으면 그 해시 함수는 유효하지 않은 것 입니다.

## 해시 함수 사용 예제

... 설명이 많아서 ... 책 참조 필요 ???
🧨


## 충돌 해결 - 분리 연결법

테이블에 이미 값이 존재하는 셀에 데이터를 추가하려고 하는 것을 **충돌** 이라고 부릅니다.

이러한 문제를 해결하는 방법중 하나는 *분리 연결법* 입니다. 충돌이 발생했을 때 셀에 하나의 값을 넣는 대신 **배열로의 참조를 넣는 방법**입니다.

다시 말해, **하나의 셀 안에 각자 다른 키-쌍 값을 가진 배열**이 또 들어있도록 만드는 것 입니다. 이럴경우 컴퓨터는 다음과 같은 단계를 밟습니다.

1. 컴퓨터는 키를 해싱합니다. (DAB = 4 * 1 * 2 = 8)
2. 셀 8 을 확인합니다. 컴퓨터는 셀 8에 하나의 값이 아닌 배열을 포함하고 있음을 확인합니다.
3. 각 하위 배열의 인덱스 0 을 찾아보며 룩업하고 있는 단어인 (dab) 을 찾을 때 까지 배열을 검색합니다.
4. 일치하는 하위 배열의 인덱스 1 에 있는 값을 반환합니다.

컴퓨터가 확인중인 셀이 배열을 참조할 경우 다수의 값이 들어있는 배열을 선형검색 해야하므로, 검색에는 단계가 더 걸립니다.

만약 모든 데이터가 해시테이블의 한 셀에 들어가게 될 경우, 해시 테이블은 배열보다 나을 게 없습니다. 따라서 최악의 경우 성능은 `O(N)` 입니다.


## 충돌 조정

해시테이블은 다음 세 요인에 따라 효율성이 정해집니다.

* 해시테이블에 얼마나 많은 데이터를 저장하는지
* 해시테이블에서 얼마나 많은 셀을 사용할 수 있는지
* 어떤 해시 함수를 사용하는지

해시 함수 자체도 효율성을 좌우하는데, **좋은 해시 함수란 모든 셀에 데이터를 분산시키는 함수**입니다.

셀이 1 ~ 10 까지 있으나 1 ~ 5 까지만 사용하면, 나머지 반은 낭비되고, 1 ~ 5 까지의 셀에 모든 데이터가 넘쳐 들어가게 될 것이기 때문입니다.

해시 테이블은 반드시 충돌 조정을 수행해야합니다. 좋은 해시테이블은 **많은 메모리를 낭비하지 않으면서 균형을 유지하며 충돌을 피합니다**.

컴퓨터 과학자들은 이러한 조건에 맞추어 규칙을 정했습니다. 데이터와 셀 간의 **부하율** 이라고 하며, 이상적인 부하율은 0.7 (원소 7개, 셀 10개) 입니다.

> 1. 처음에 해시에 데이터를 7개 저장했다면, 컴퓨터는 셀 10 개로 이루어진 해시를 할당합니다.
> 2. 그러나 데이터를 더 추가하기 시작하면 새 데이터가 새로운 셀들에 균등하게 분산되도록 셀을 추가하고 해시 함수를 바꿔서 해시를 더 확장할 것 입니다.

이제 해시가 어떻게 동작하는지 알았으니, 배열 대신 해시를 사용하여 코드의 성능을 최적화하고 효율성 `O(1)` 의 룩업을 사용할 수 있습니다.

## 실제 예제

해시 테이블에는 실용적인 사용 사례들이 많지만, 여기서는 알고리즘의 속도를 높이는데 초점을 맞춥니다.
🧨

