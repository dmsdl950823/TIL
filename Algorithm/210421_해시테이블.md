- [해시 테이블](#해시-테이블)
	- [해시 함수로 해싱](#해시-함수로-해싱)
	- [해시 함수 절차](#해시-함수-절차)
		- [값 저장](#값-저장)
		- [값 확인](#값-확인)
	- [충돌 해결 - 분리 연결법](#충돌-해결---분리-연결법)
	- [충돌 조정](#충돌-조정)
	- [실제 예제](#실제-예제)
	- [마무리](#마무리)


# 해시 테이블

대부분의 프로그래밍 언어는 *해시 테이블* (hash table) 이라는 자료 구조를 포함하며, **빠른 읽기** 라는 능력을 가지고 있습니다.

해시 테이블은, *해시*, *해시 맵*, *딕셔너리*, *연관 배열* 등 다양한 언어에서 다양한 이름으로 불립니다.

``` ruby
	menu = {
		"french fries" => 0.75,
		"hamberger" => 2.5,
		"hot dog" => 1.5,
		"soda" => 0.6
	}
```

해시 테이블은 **키 - 값 쌍으로 이루어진 리스트**입니다. `french fires` 는 **키**이며, 값을 가지고 있습니다.
해시 테이블에서 키와 값은 서로 중요한 관계를 가집니다.

해시 테이블의 각 룩업은 딱 한 단계만 걸리므로 평균적으로 효율성이 `O(1)` 입니다.

## 해시 함수로 해싱

비밀 코드를 만든다고 가정하자.

```  
	A = 1    
	B = 2    
	c = 3    
	d = 4 ... 
```

|     | 변환된 값 |
| --- | --------- |
| ACE | 135       |
| CAB | 312       |
| DAB | 412       |
| BAD | 214 ...   |

문자를 가져와 숫자로 변환하는 이러한 과정을 **해싱**이라 부릅니다. 또한, 글자를 특정 숫자로 변환하는데 사용한 코드를 **해시 함수** 라고 부릅니다.

이 밖에 해시 함수는 많은데, *각 문자에 해당하는 숫자를 가져와 모든 수를 합쳐서 반환하는 방법*도 있습니다.

BAD 를 예로 들면,

> 1. 먼저 BAD 를 214 로 변환합니다.
> 2. 각 숫자를 가져와 합칩니다. (2 + 1 + 4 = 7)

또 다른 해시 함수예제로는 *문자에 해당하는 모든 수를 곱해서 반환* 하는 방법입니다.

> 1. 먼저 BAD 를 214 로 변환합니다.
> 2. 각 숫자를 가져와 곱합니다 (2 * 1 * 4 = 8)

실제 쓰이는 해시 함수는 이보다 더 복잡합니다.

------

해시 함수가 유효하려면 딱 한가지 기준을 충족해야하는데,

* 동일한 문자열을 해시 함수에 적용할 때마다 **항상 동일한 숫자로 변환**해야합니다.
* 반환하는 결과가 일관되지 않으면 그 해시 함수는 유효하지 않은 것 입니다.

## 해시 함수 절차

배열과 유사하게 해시 테이블은 내부적으로 데이터를 한 줄로 이루어진 셀 묶음에 저장합니다.
각 셀마다는 주소가 있습니다.

### 값 저장

``` ruby
	hashTable = {}

 | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  | 16  |
 | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
 |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |
```

항목을 해시에 추가할경우,
해시 테이블이 키를 해싱하여 해당 위치 (여기서는 BAD = 2 * 1 * 4 = 8 을 이용합니다) 에 값을 입력합니다.

``` ruby
	hashTab['bad'] = 'evil'
	# { 'bad' => 'evil' }
	
 | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8      | 9   | 10  | 11  | 12  | 13  | 14  | 15  | 16  |
 | --- | --- | --- | --- | --- | --- | --- | ------ | --- | --- | --- | --- | --- | --- | --- | --- |
 |     |     |     |     |     |     |     | 'evil' |     |     |     |     |     |     |     |     |
```

다른 키 / 값 쌍을 추가할경우, 해시 테이블이 해싱하여 해당 위치에 저장합니다.

``` ruby
	hashTab['cab'] = 'taxi'
	# { 'cab' => 'taxi' }
	
 | 1   | 2   | 3   | 4   | 5   | 6      | 7   | 8      | 9   | 10  | 11  | 12  | 13  | 14  | 15  | 16  |
 | --- | --- | --- | --- | --- | ------ | --- | ------ | --- | --- | --- | --- | --- | --- | --- | --- |
 |     |     |     |     |     | 'taxi' |     | 'evil' |     |     |     |     |     |     |     |     |
```

이제 해시 테이블은 아래와 같습니다.

``` ruby
	{ 'bad' => 'evil', 'cab' => 'taxi' }
```

### 값 확인

키 `bad` 값을 확인하고 싶은경우, 컴퓨터는 간단히 두 단계를 실행합니다.

``` ruby
	hashTab['bad']
```

1. 컴퓨터는 해당 키를 해싱합니다. (BAD = 2 * 1 * 4 = 8)
2. 결과가 8 이므로 셀 8을 찾아서 저장된 값을 반환합니다. (여기서는 문자열 `'evil'`)

이제 왜 해시 테이블의 값 룩업이 전형적으로 `O(1)` 인지 알았습니다. `O(N)` 은 상수 시간이 걸리는 절차입니다. 컴퓨터는 룩업하고 있는 키를 해싱해서 해당하는 값을 얻고 그 값에 해당하는 셀로 바로 갑니다.

배열에서 특정 값을 확인하려면 항목을 찾을 때 까지 각 셀을 순회해서 검색해야했습니다. (최소 `O(log N)` ~ 최대 `O(N)` 까지 걸림)

해시 테이블을 사용하면 값을 확인하는데 `O(1)` 만에 할 수 있습니다.

## 충돌 해결 - 분리 연결법

테이블에 이미 값이 존재하는 셀에 데이터를 추가하려고 하는 것을 **충돌** 이라고 부릅니다.

이러한 문제를 해결하는 방법중 하나는 *분리 연결법* 입니다. 충돌이 발생했을 때 셀에 하나의 값을 넣는 대신 **배열로의 참조를 넣는 방법**입니다.

다시 말해, **하나의 셀 안에 각자 다른 키-쌍 값을 가진 배열**이 또 들어있도록 만드는 것 입니다. 이럴경우 컴퓨터는 다음과 같은 단계를 밟습니다.

1. 컴퓨터는 키를 해싱합니다. (DAB = 4 * 1 * 2 = 8)
2. 셀 8 을 확인합니다. 컴퓨터는 셀 8에 하나의 값이 아닌 배열을 포함하고 있음을 확인합니다.
3. 각 하위 배열의 인덱스 0 을 찾아보며 룩업하고 있는 단어인 (dab) 을 찾을 때 까지 배열을 검색합니다.
4. 일치하는 하위 배열의 인덱스 1 에 있는 값을 반환합니다.

컴퓨터가 확인중인 셀이 배열을 참조할 경우 다수의 값이 들어있는 배열을 선형검색 해야하므로, 검색에는 단계가 더 걸립니다.

만약 모든 데이터가 해시 테이블의 한 셀에 들어가게 될 경우, 해시 테이블은 배열보다 나을 게 없습니다. 따라서 최악의 경우 성능은 `O(N)` 입니다.


## 충돌 조정

해시 테이블은 다음 세 요인에 따라 효율성이 정해집니다.

* 해시 테이블에 얼마나 많은 데이터를 저장하는지
* 해시 테이블에서 얼마나 많은 셀을 사용할 수 있는지
* 어떤 해시 함수를 사용하는지

해시 함수 자체도 효율성을 좌우하는데, **좋은 해시 함수란 모든 셀에 데이터를 분산시키는 함수**입니다.

셀이 1 ~ 10 까지 있으나 1 ~ 5 까지만 사용하면, 나머지 반은 낭비되고, 1 ~ 5 까지의 셀에 모든 데이터가 넘쳐 들어가게 될 것이기 때문입니다.

해시 테이블은 반드시 충돌 조정을 수행해야합니다. 좋은 해시 테이블은 **많은 메모리를 낭비하지 않으면서 균형을 유지하며 충돌을 피합니다**.

컴퓨터 과학자들은 이러한 조건에 맞추어 규칙을 정했습니다. 데이터와 셀 간의 **부하율** 이라고 하며, 이상적인 부하율은 0.7 (원소 7개, 셀 10개) 입니다.

> 1. 처음에 해시에 데이터를 7개 저장했다면, 컴퓨터는 셀 10 개로 이루어진 해시를 할당합니다.
> 2. 그러나 데이터를 더 추가하기 시작하면 새 데이터가 새로운 셀들에 균등하게 분산되도록 셀을 추가하고 해시 함수를 바꿔서 해시를 더 확장할 것 입니다.

이제 해시가 어떻게 동작하는지 알았으니, 배열 대신 해시를 사용하여 코드의 성능을 최적화하고 효율성 `O(1)` 의 룩업을 사용할 수 있습니다.

## 실제 예제

해시 테이블에는 실용적인 사용 사례들이 많지만, 여기서는 알고리즘의 속도를 높이는데 초점을 맞춥니다.

투표소에서, 1. 투표자가 후보자 목록중 하나를 고르거나, 2. 또 다른 후보자를 작성할 수 있는 전자투표 기계를 만드는 예제입니다.

일반적으로는 간단한 배열로 저장해서, 각 투표가 들어오는 대로 배열 끝에 삽입하는 방법을 이용합니다.

``` js
	const votes = []
	function addVote (candidate) {
		votes.push(candidate)
	}

	/*
		// 투표하는중 || 후보자를 추가하는중...
		for (let p = 0; p < people.length; p++) {
			const element = people[p];
			addVote(element)
		}

		// votes 결과
		// [ 'A', 'A', 'B', 'C', 'A', 'C', 'D', 'E', 'D' ]
	*/
```

이렇게 배열로 저장했을 경우, 최종 득표수를 구하려면 아래와 같이 루프를 사용해야합니다.

``` js
	/**
	 * 각 후보들의 득표수를 구합니다 (선형 검색)
	 * @param {Array} votes 후보들 
	 * @returns 각 후보들의 개인 득표수
	 */
	function countVotes (candis) {
		const tally = {}

		for (let i = 0; i < candis.length; i++) {
			const candi = [candis[i]]
			if (tally[candi]) tally[candi]++
			else tally[candi] = 1
		}

		return tally
	}

	const people = ['A' ,'A', 'B', 'C', 'A', 'C', 'D', 'E', 'D']
	countVotes(people)  // { A: 3, B: 1, C: 2, D: 2, E: 1 }
```

이렇게하면 `O(N)`, 너무 오래걸리는 방법입니다.

-------

이렇게 하는 대신, 배열 대신 처음부터 해시 테이블에 데이터를 저장하는 방법을 이용합니다.

``` js
	const votes = {}
	function addVote (candidate) {
		if (votes[candidate]) votes[candidate]++
		else votes[candidate] = 1
	}

	// 투표하는중 || 후보자를 추가하는중...
	// votes 결과 
	// { A: 3, B: 1, C: 2, D: 2, E: 1 }
```

위 방법은 삽입이 `O(1)` 일 뿐 아니라 투표를 할 때마다 투표 수를 기록하므로 최종 득표수를 세는데도 마찬가지로 `O(1)` 입니다.

## 마무리

해시 테이블은 효율적인 소프트웨어 개발에 필수입니다.

효율성과 속도도 물론 중요하지만, 그 외에 장범을 제공하는 자료구조도 있으므로 다음 강의에서 살펴볼 것이다.