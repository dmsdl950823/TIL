# 노드 기반 자료 구조

- [노드 기반 자료 구조](#노드-기반-자료-구조)
  - [연결 리스트](#연결-리스트)
  - [연결 리스트 구현](#연결-리스트-구현)
    - [읽기](#읽기)
    - [검색](#검색)
    - [삽입](#삽입)
    - [삭제](#삭제)
  - [연결 리스트 살펴보기](#연결-리스트-살펴보기)
  - [이중 연결 리스트](#이중-연결-리스트)
  - [마무리](#마무리)

지금부터 다룰 자료구조는 모두 **노드(Node)** 라는 개념에 기반해 만들어졌습니다. 노드 기반 자료구조는 데이터를 조직하고 접근하는 새로운 방법을 제공하는데 성능상 큰 이점이 많습니다.

연결리스트와 배열이 비슷해 보이지만, 연결리스트는 효율성 면에서 장단점trade-off 이 있어 어떤 상황에서 성능이 크게 높아지는지도 알아볼 것 입니다.

## 연결 리스트

*연결리스트* (linked list) 는 배열과 마찬가지로 **항목의 리스트를 표현하는 자료 구조**입니다. 그러나 배열과 연결리스트는 내부적으로 서로 다르게 구현되며, 상황에 따라 성능이 다를 수 있습니다. 배열과의 차이점은 아래와 같습니다.


<img src="https://lh3.googleusercontent.com/proxy/SgV2XchhoQXR8fDfZLfpkAUnYcZ8tkGri9o7aHJju0CEPbirQvPNRSh__UIwPMyUF30cZbyIWeONWdd4y62Fb9FgBFhRCMwFF8VVib9JCPQKaE8SznBfYEPOYL2dWEKTCTxO6vCjBSBLvXVbgFzQTLgPzDLS7PCmV6SyTEGf1KhMLQgHfpv47RkhO1M" width=400>

* **배열**
  * 배열을 생성하면 메모리 내에서 **연속된 빈 셀 그룹**에 데이터를 저장할 수 있도록 할당합니다. 
  * 배열 내 어떤 인덱스든 한번에 갈 수 있습니다.


* **연결리스트**
  * 나란히 이어진 메모리 셀 묶음이 아니라 **서로 인접하지 않은 메모리 셀 묶음**으로 이루어집니다. 이러한 노드를 노드 라고 부릅니다.
  * 프로그램이 데이터를 저장하기 위해 메모리 내에 나란히 이어진 빈 셀 묶음을 찾을 필요가 없으므로 메모리를 효율적으로 사용할 수 있습니다.
  * 서로 인접하지 않은 여러 셀에 걸쳐 데이터를 저정할 수 있으므로 동적입니다.
  * 각 노드는 **데이터**와 **연결리스트 내에 연결된 노드의 메모리 주소도 저장**합니다.
  * 한개의 노드는 셀 두개씩, **[데이터 | 링크주소]** 로 이루어져있습니다.
  * 마지막 노드의 링크 주소에는 연결리스트가 끝나므로 `null` 입니다.
  * 각 노드는 다음 링크를 포함하고있으므로 노드의 링크를 따라서 나머지 리스트를 조합할 수 있습니다.
 
## 연결 리스트 구현

``` js
    function Node (data) {
        return {
            data,
            nextNode: null
        }
    }

    const node_1 = new Node('once')
    const node_2 = new Node('upon')
    node_1
    node_1.nextNode = node_2
    node_2
    const node_3 = new Node('a')
    node_2.nextNode = node_3
    const node_4 = new Node('time')
    node_3.nextNode = node_4

    node_1
    /*
        {
        data: 'once', nextNode: {
            data: 'upon', nextNode: {
            data: 'a', nextNode: {
                data: 'time', nextNode: null
            }
            }
        }
        }
    */
```

`Node` 클래스만 있어도 연결리스트를 생성할 순 있지만, 프로그램에게 연결리스트가 어디서부터 시작하는지 쉽게 알려줄 방법이 필요합니다.

### 읽기

컴퓨터가 배열에서 값을 읽을 때는 한 단계, `O(1)` 만에 해당 셀을 갈 수 있지만, 연결 리스트는 그렇지 않습니다.

연결리스트의 각 노드는, 메모리의 어디든 분포해있을 수 있기 때문입니다. 프로그램은 **연결 리스트의 첫 번째 노드의 메모리 주소만 알고있습니다.** 

### 검색

``` js
    // 수정중!
    /**
     * @param {Object} node
     */
    function LinkedList (node) {
        const attrAccessor = node
        const firstNode = JSON.parse(JSON.stringify(node))

        const read = index => {
            // 리스트의 첫 번째 노드부터 시작합니다.
            const currentNode = firstNode
            const currentIdx = 0

            while (currentIdx < index) {
                // 찾고있는 인덱스에 도착할 때 까지 각 노드의 링크를 계속 따라갑니다.
                currentNode = currentNode.nextNode
                currentIdx += 1

                // 리스트의 끝에 도착했으면 찾고있는 값이 리스트에 없다는 의미로
                // null 을 반환합니다.
                // if (currentNode)
                return unll
            }
            return currentNode.data
        }
        read()
    }

    LinkedList(1)
```

### 삽입

### 삭제

## 연결 리스트 살펴보기

## 이중 연결 리스트

## 마무리
