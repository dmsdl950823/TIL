# 노드 기반 자료 구조

- [노드 기반 자료 구조](#노드-기반-자료-구조)
  - [연결 리스트](#연결-리스트)
  - [연결 리스트 구현](#연결-리스트-구현)
    - [읽기](#읽기)
    - [검색](#검색)
    - [삽입](#삽입)
    - [삭제](#삭제)
  - [연결 리스트 다뤄보기](#연결-리스트-다뤄보기)
  - [이중 연결 리스트](#이중-연결-리스트)
  - [마무리](#마무리)

지금부터 다룰 자료구조는 모두 **노드(Node)** 라는 개념에 기반해 만들어졌습니다. 노드 기반 자료구조는 데이터를 조직하고 접근하는 새로운 방법을 제공하는데 성능상 큰 이점이 많습니다.

연결리스트와 배열이 비슷해 보이지만, 연결리스트는 효율성 면에서 장단점trade-off 이 있어 어떤 상황에서 성능이 크게 높아지는지도 알아볼 것 입니다.

## 연결 리스트

*연결리스트* (linked list) 는 배열과 마찬가지로 **항목의 리스트를 표현하는 자료 구조**입니다. 그러나 배열과 연결리스트는 내부적으로 서로 다르게 구현되며, 상황에 따라 성능이 다를 수 있습니다. 배열과의 차이점은 아래와 같습니다.


<img src="https://lh3.googleusercontent.com/proxy/SgV2XchhoQXR8fDfZLfpkAUnYcZ8tkGri9o7aHJju0CEPbirQvPNRSh__UIwPMyUF30cZbyIWeONWdd4y62Fb9FgBFhRCMwFF8VVib9JCPQKaE8SznBfYEPOYL2dWEKTCTxO6vCjBSBLvXVbgFzQTLgPzDLS7PCmV6SyTEGf1KhMLQgHfpv47RkhO1M" width=400>

* **배열**
  * 배열을 생성하면 메모리 내에서 **연속된 빈 셀 그룹**에 데이터를 저장할 수 있도록 할당합니다. 
  * 배열 내 어떤 인덱스든 한번에 갈 수 있습니다.


* **연결리스트**
  * 나란히 이어진 메모리 셀 묶음이 아니라 **서로 인접하지 않은 메모리 셀 묶음**으로 이루어집니다. 이러한 노드를 노드 라고 부릅니다.
  * 프로그램이 데이터를 저장하기 위해 메모리 내에 나란히 이어진 빈 셀 묶음을 찾을 필요가 없으므로 메모리를 효율적으로 사용할 수 있습니다.
  * 서로 인접하지 않은 여러 셀에 걸쳐 데이터를 저정할 수 있으므로 동적입니다.
  * 각 노드는 **데이터**와 **연결리스트 내에 연결된 노드의 메모리 주소도 저장**합니다.
  * 한개의 노드는 셀 두개씩, **[데이터 | 링크주소]** 로 이루어져있습니다.
  * 마지막 노드의 링크 주소에는 연결리스트가 끝나므로 `null` 입니다.
  * 각 노드는 다음 링크를 포함하고있으므로 노드의 링크를 따라서 나머지 리스트를 조합할 수 있습니다.
 
## 연결 리스트 구현

``` js
    function Node (data) {
        return {
            data,
            nextNode: null
        }
    }

    // 연결리스트 생성
    const node_1 = new Node('once')
    const node_2 = new Node('upon')
    node_1.nextNode = node_2
    
    const node_3 = new Node('a')
    node_2.nextNode = node_3
    
    const node_4 = new Node('time')
    node_3.nextNode = node_4

    console.log(node_1)
    /*
      {
        data: 'once', nextNode: { // node_1
          data: 'upon', nextNode: { // node_2
            data: 'a', nextNode: {  // node_3
              data: 'time', nextNode: null // node_4
            }
          }
        }
      }
    */
```

`Node` 클래스만 있어도 연결리스트를 생성할 순 있지만, 프로그램에게 연결리스트가 어디서부터 시작하는지 쉽게 알려줄 방법이 필요합니다.

### 읽기

컴퓨터가 배열에서 값을 읽을 때는 한 단계, `O(1)` 만에 해당 셀을 갈 수 있지만, 연결 리스트는 그렇지 않습니다.

연결리스트의 각 노드는, 메모리의 어디든 분포해있을 수 있기 때문입니다. 프로그램은 **연결 리스트의 첫 번째 노드의 메모리 주소만 알고있습니다.** 

### 검색

``` js
    // Node () ...

    /**
     * 읽기
     * @param {Object} node
     */
    function LinkedList (node) {
        const attrAccessor = node // (?)
        const firstNode = JSON.parse(JSON.stringify(node))

        return {
            /**
             * 읽기 - 찾는 인덱스를 받아 해당 인덱스에 있는 값(data)을 반환합니다.
             * @param {Number} index
             */
            read (index) {
                // 리스트의 첫 번째 노드부터 시작합니다.
                let currentNode = firstNode
                let currentIdx = 0

                while (currentIdx < index) {
                    // 찾고있는 인덱스에 도착할 때 까지 각 노드의 링크를 계속 따라갑니다.
                    currentNode = currentNode.nextNode
                    currentIdx += 1

                    // 찾는 인덱스에 값이 없을 경우 null 반환
                    if (!currentNode) return null
                }
                return currentNode.data
            },

            // ...
        }

    }


    // 연결리스트 생성...
    // 연결리스트 사용
    const list = new LinkedList(node_1)

    // 읽기
    list.read(1) // 'upon' => node_2 { data: 'upon', nextNode: { ... } } } 
```

### 삽입

### 삭제

## 연결 리스트 다뤄보기

연결 리스트가 가장 유용한 경우는 한 리스트를 검사해서 **많은 원소를 삭제**할 때 입니다.

이메일 주소 리스트를 샅샅이 검토해서 유효하지 않은 형식의 이메일을 모두 삭제하는 앱을 만든다고 가정합니다. 

배열, 연결리스트 모두 한 번에 한 원소씩 살펴보며 각 값을 검사해야하므로 총 N 단계가 걸립니다.

하지만 실제로 이메일 주소를 삭제할 때는,

* 배열
  * 삭제할 때마다 빈 공간을 메우기 위해 나머지 데이터를 왼쪽으로 이동해야하는 `O(N)` 단계가 더 필요합니다. 모든 시프트는 다음 이메일 주소를 검사하기도 전에 일어납니다.
  * 모든 이메일 주소 *읽기* N 단계 + (불필요한 이메일주소 개수 * N 단계) *삭제* 단계
    > ex) 전체 이메일 주소 1,000 개중 유효하지 않은 이메일은 100 개 라고 가정합니다.
    > 
    > 읽기 1,000 단계 + 삭제 100,000 단계 (유효하지않는 이메일 100 개 * N) 
* 연결 리스트
  * 전체를 살펴보면서 삭제가 필요하면 그 노드의 링크가 적절한 노드를 가리키도록 바꾸면 되므로 **삭제마다 딱 한 단계가 걸립니다.**
    > ex) 1,000 개의 읽기 단계 + 100 개의 삭제 단계

## 이중 연결 리스트

## 마무리
