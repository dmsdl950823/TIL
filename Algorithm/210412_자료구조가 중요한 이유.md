- [자료구조가 중요한 이유](#자료구조가-중요한-이유)
	- [배열](#배열)
	- [연산](#연산)
		- [**읽기**](#읽기)
		- [**검색**](#검색)
		- [**삽입**](#삽입)
		- [**삭제**](#삭제)
	- [집합](#집합)
		- [**읽기**](#읽기-1)
		- [**검색**](#검색-1)
		- [**삭제**](#삭제-1)
		- [**삽입**](#삽입-1)

# 자료구조가 중요한 이유

데이터 조직이 **코드의 실행 속도에 미치는 영향**은 큽니다. 데이터를 어떻게 조직하느냐에 따라 더 빠르게, 더 느리게 실행될 수 있습니다. 대량의 데이터를 처리해야하는 프로그램이나 수천 명의 사람들이 사용하는 페이지일 경우, 선택한 자료구조가 앱을 더 빠르게, 혹은 앱이 멈춰버리게 등을 결정할 수도 있습니다.

소프트웨어를 문제없이, 빠르게 실행할 수 있는 명쾌한 코드를 작성하는 능력을 갖추고 소프트웨어 공학자가 가져야 하는 전문성을 키우려면 다양한 자료구조를 알고, 각 자료구조가 개발 중인 프로그램의 성능에 어떤 영향을 미치는지 확실히 이해해야합니다.

## 배열

*배열*은 단순히 **데이터 원소들의 리스트**입니다.

배열의 *인덱스*는 특정 데이터가 배열의 어디에 있는지 알려주는 숫자입니다.
대부분의 프로그래밍 언어에서 인덱스는 0부터 시작합니다.

## 연산
대부분의 자료구조는 네 가지 기본 방법을 사용하며, 이를 **연산**이라 부릅니다.

* **읽기** :: 자료 구조에서 특정 인덱스의 값을 찾아보는 것
* **검색** :: 자료 구조에서 특정 값을 찾는 것
* **삽입** :: 자료 구조에서 새로운 값을 추가하는 것
* **삭제** :: 자료 구조에서 특정 값을 제거하는 것

연산이 얼마나 빠른가를 측정할 때에는 시간 뿐만 아니라 얼마나 많은 단계가 필요한지를 고려해야합니다.

시간은 하드웨어에 따라 항상 바뀌므로, 시간을 기준으로 속도를 측정하면 신뢰할만한 결과를 얻을 수 없습니다. 대신 연산의 속도를 측정할 때 얼마나 많은 **단계 step** 가 필요한지를 따져보아야 합니다.

연산의 속도 측정은 연산의 **시간 복잡도**, **속도**, **효율성**, **성능** - 주어진 연산에 걸리는 단계 수를 나타냄 - 를 고려해야합니다.

### **읽기**

*읽기*는 **배열 내 특정 인덱스에 어떤 값이 들어있는지 찾아보는 것** 입니다.

배열에서 읽기는 실제로 **한 단계**가 걸립니다. 컴퓨터는 배열 내 특정 인덱스에 한번에 접근할 수 있기 때문입니다. 이렇게 한 번의 단계로 바로 갈 수 있는 이유는 복합적으로 작용하는 요인들이 있기 때문입니다.

  1. 컴퓨터는 모든 메모리 주소에 한 번에 갈 수 있습니다.
  2. 각 배열에 저장된 내용은 메모리의 시작 주소입니다. - 컴퓨터가 쉽게 시작 주소를 얻습니다.
  3. 배열의 인덱스가 0 부터 시작합니다.

### **검색**

*검색* 은 배열에 특정 값이 있는지 알아본 후, 있다면 어떤 인덱스에 있는지 **찾습니다**.

컴퓨터는 배열을 검색할 때 **차례대로** 배열을 돌아 값을 찾습니다. (**선형 검색**)
인덱스를 돌아 원하는 값을 발견한 경우, 컴퓨터는 해당 인덱스 이후의 값을 검색하지 않습니다.

찾고있는 값이 배열의 마지막 셀에 있을 경우, 컴퓨터는 값을 찾을 때 까지 배열의 모든 셀을 검색해야합니다. 찾는 값이 배열에 없는 경우에는, 모든 셀을 검색해야 비로소 배열에 값이 없다고 확신할 수 있습니다. 단계는 **배열의 갯수 와 동일하게 (N) 단계**가 걸립니다.

그러므로 검색에는 많은 단계가 걸릴 수 있습니다.

<small>
	** N 개의 셀로 이루어진 배열에서 선형 검색에 걸리는 최대 단계수는 N 입니다. <br>
	** 5 개의 셀로 이루어진 배열에서 선형 검색에 걸리는 최대 단계수는 5 입니다.
</small>


### **삽입**

*삽입*은 데이터를 **배열의 어디에 삽입하는지에 따라** 효율성이 다릅니다.

맨 끝에 데이터를 추가할 경우, 컴퓨터는 배열의 시작 주소를 알고있기 때문에, **한 단계**가 걸립니다.

그러나 맨 처음 / 중간 에 데이터를 삽입하면, 삽입할 공간을 만들기 위해 그만큼의 데이터 조각을 이동시켜야하므로 단계가 늘어납니다. 맨 앞에 삽입할 경우, 모든 값을 한 셀씩 오른쪽으로 옮겨야 하므로 **배열의 갯수 + 1 (N + 1) 단계**가 걸립니다.

### **삭제**

배열의 *삭제*는 특정 인덱스를 제거하는 과정입니다.

실제로는 한 단계만 걸리지만, 비어있는 셀을 채워주어야 하므로 삭제된 인덱스 뒤의 데이터들이 한 개씩 왼쪽으로 이동합니다.

배열의 첫 번째 원소를 삭제할 경우, 남아있는 모든 원소를 모두 왼쪽으로 이동시켜 빈 공간을 채워야 하므로 **배열의 갯수 (N) 단계** 가 걸립니다.


## 집합

*집합*은 중복 데이터가 없어야 할 때 유용하다.

### **읽기**
집합 *읽기*는 배열 읽기와 동일하며, 인덱스에 들어있는 값을 찾는데 **한 단계** 면 된다. 컴퓨터는 인덱스 값을 알면 집합 내 어떤 인덱스든 한 번에 찾을 수 있다.

### **검색**
집합 *검색*도 배열 검색과 동일하며, 어떤 값을 검색하는데 **최대 N 단계** 까지 걸릴 수 있다. 

### **삭제**

집합 *삭제* 도 배열 삭제와 동일하며, 값을 삭제하고 빈 공간을 채우기 위해 **N 단계**를 거쳐 데이터를 왼쪽으로 옮긴다.

### **삽입**

집합 *삽입* 은 배열과 다른데, 모든 원소를 먼저 검색 한후 중복되는 값이 없으면 삽입을 시도한다.

|              | 배열          | 집합                                                                 |
| ------------ | ------------- | -------------------------------------------------------------------- |
| 맨 끝에 삽입 | 1 단계 (최선) | 원소 검색, 삽입 N + 1 단계 (최선)                                    |
| 맨 앞에 삽입 | N + 1 단계    | 원소 검색, 데이터 모두 오른쪽으로 옮긴 후 삽입 총 2N + 1 단계 (최악) |

삽입이 느리다고 하더라도  중복 데이터가 없어야 할 때는 집합을 사용해야한다.

앱의 요구사항을 먼저 분석한 후 어떤 자료구조가 더 적합한지 결정해야한다.