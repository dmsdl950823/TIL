- [속도를 높이는 재귀 알고리즘](#속도를-높이는-재귀-알고리즘)
  - [분할](#분할)
    - [단계](#단계)
  - [퀵 정렬](#퀵-정렬)
  - [퀵 정렬의 효율성](#퀵-정렬의-효율성)
  - [최악의 시나리오](#최악의-시나리오)
  - [퀵 셀렉트](#퀵-셀렉트)
  - [마무리](#마무리)

# 속도를 높이는 재귀 알고리즘

이전에 버블 정렬, 선택 정렬, 삽입 정렬 같은 정렬 알고리즘을 살펴봤으나, 실제로 컴퓨터 언어에선 내장 정렬 함수가 있어 개발자의 시간과 노력을 아껴줍니다. 컴퓨터 언어 대다수가 내부적으로 채택한 정렬 알고리즘이 *퀵 정렬* 입니다.

퀵 정렬의 동작 방식을 공부함으로써 재귀를 사용하여 어떻게 알고리즘의 속도를 크게 향상 시키는지 확인할 수 있습니다.

퀵 정렬은 매우 빠른 정렬 알고리즘으로, 특히 평균 시나리오에서 효율적입니다.

## 분할

퀵 정렬은 *분할* 이라는 개념에 기반합니다.

배열을 분할한다는 것은, 배열로부터 임의의 수를 가져와(피벗) 피벗보다 작은 모든 수는 피벗의 왼쪽, 피벗보다 큰 모든 수는 피벗의 오른쪽에 둡니다.

<img src="http://dawoonjeong.com/assets/images/posts/2020/algorithm-quick_sort_partition_animation.gif" width=400/>

### 단계


1. 왼쪽 포인터를 한 셀씩 계속 오른쪽으로 옮기면서 피벗보다 크거나 같은 값에 도달하면 멈춥니다.
2. 이어서 오른쪽 포인터를 한 셀씩 계속 왼쪽으로 옮기면서 피벗보다 작거나 같은 값에 도달하면 멈춥니다.
3. 왼쪽 포인터와 오른쪽 포인터가 가리키고있는 값을 교환합니다.
4. 두 포인터가 가리키는 값이 같거나 왼쪽포인터가 오른쪽 포인터 바로 오른쪽으로 이동할 때 까지 위 과정을 반복합니다.
5. 끝으로 왼쪽 포인터가 현재 가리키고 있는 값과 피벗을 교환합니다.


``` ruby
    class SortableArray
    
    attr_reader :array
    
    def initialize(array)
        @array = array
    end

    def partition!(left_pointer, right_pointer)
        
        # 항상 가장 오른쪽에 있는 값을 피벗으로 함
        pivot_position = right_pointer
        pivot = @array[pitvot_position]
        
        # 피벗 바로 왼쪽에서 오른쪽 포인터를 시작시킨다
        right_pointer -= 1
        
        while true do
           
           while @array[left_pointer] < pivot do
                left_pointer += 1
           end
           
           while @array[right_pointer] > pivot do
                right_pointer -= 1 
           end
           
           if left_pointer >= right_pointer
                break
            else
                swap(left_pointer, right_pointer)
           end
        end
        
        #
        swap(left_pointer, pivot_position)
        
        return left_pointer
    end
    
    def swap(pointer_1, pointer_2)
        temp_value = @array[pointer_1]
        @array[pointer_1] = @array[pointer_2]
        @array[pointer_2] = temp_value
    end
    
    def quicksort!(left_index, right_index)
        # 기저 조건 : 하위 배열 원소가 0개 또는 1개일 때
        if right_index - left_index <= 0
            return
        end
        
        
        # 배열을 분할하고 피벗의 위차를 가져옵니다.
        pivot_position = partition!(left_index, right_index)
        
        # 파벗 왼쪽에 대해 quicksort! 메서드를 재귀적으로 호출합니다
        quicksort!(left_index, pivot_position - 1)
        
        # 피벗 오른쪽에 대해 quicksort! 메서드를 재귀적으로 호출합니다.
        quicksort!(pivot_position + 1, right_index)
    end
end


array = [0, 5, 2, 1, 6, 3]

sortable_array = SortableArray.new(array)
sortable_array.quicksort!(0, array.length - 1)
p sortable_array.array
```

## 퀵 정렬

퀵 정렬 알고리즘에는 분할이 중요합니다.

1. 배열을 분할합니다. 피벗은 이제 올바른 위치에 있습니다.
2. 피벗의 왼쪽, 오른쪽에 있는 하위 배열을 각각 또 다른 배열로 보고 1단계와 2 단계를 재귀적으로 반복합니다. 각 하위 배열을 분할하고 각 하위 배열에 있는 피벗의 왼쪽/오른쪽에서 더 작아진 하위 배열을 얻습니다. 이러한 하위 배열을 다시 분할하는 과정을 반복합니다.
3. 하위 배열이 원소 0개 또는 1개를 포함하면 기저 조건이므로 아무것도 하지 않습니다.

## 퀵 정렬의 효율성

## 최악의 시나리오

## 퀵 셀렉트

## 마무리