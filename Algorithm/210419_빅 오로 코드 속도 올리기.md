- [빅 오로 코드 속도 올리기](#빅-오로-코드-속도-올리기)
	- [버블 정렬](#버블-정렬)
	- [버블 정렬 구현](#버블-정렬-구현)
	- [버블 정렬의 효율성](#버블-정렬의-효율성)
	- [이차 문제](#이차-문제)
	- [선형 해결법](#선형-해결법)
	- [마무리](#마무리)

# 빅 오로 코드 속도 올리기

일상적으로 프로그래머는 작성하는 코드에서도 선형검색, 이진 검색 두가지가 바로 떠오르는 것이 아니라,
가장 먼저 떠오른 방법을 시도할 가능성이 높습니다. 빅 오를 사용하면 내가 만든 알고리즘과 범용 알고리즘을 비교할 기회가 생기며 "이 알고리즘이 일반적으로 사용되는 알고리즘만큼 빠른가/느린가" 를 확인해 볼 수 있습니다.

빅 오에서 내가 만든 알고리즘을 "느린" 알고리즘이라고 생각한다면 최적화하는 방법을 찾아 볼 수 있습니다. 

## 버블 정렬

*정렬 알고리즘* 은 컴퓨터 과항 분야에서 폭넓게 연구된 주제이며, 지난 수년간 수십 개의 정렬 알고리즘이 개발되어 왔습니다. 
```
	정렬되지 않은 배열이 주어졌을 때, 어떻게 오름차순으로 정렬할 수 있을까?
```

*단순 정렬*(simple sort) 알고리즘은, 이해하기 쉽지만, 더 빠르다고 알려진 정렬 알고리즘보다 비효율적 입니다.

*버블 정렬* 은 매우 기본적인 알고리즘은 다음과 같은 단계를 밟습니다.

1. 배열 내에서 연속된 두 항목을 선택하여 비교합니다. (처음에는 0, 1 번째 요소를 가리킵니다)
2. 왼쪽 값이 오른쪽 값보다 크면 두 항목을 교환(swap) 합니다. (순서가 올바르다면 2단계에선 아무것도 하지 않습니다.)
3. 포인터를 오른쪽으로 한 셀씩 옮깁니다. (1, 2 요소를 가리킵니다)
   > 배열의 끝 까지, 또는 이미 정렬된 어떤 항목까지 1 단계 2 단계를 반복합니다.
4. 더 이상 교환하지 않을 때 까지 1 단계부터 3 단계를 반복합니다.
   > 더는 교환을 하지 않는다는 것은 배열이 정렬된 상태라는 의미 입니다.

버블 정렬에서 1 단부터 3 단계 까지 반복하는 것을 *패스 스루*(passthrough) 라고 부릅니다. 알고리즘의 주요 단계들을 **통과** 했다는 의미이며, 완전히 정렬될 때 까지 같은 절차를 반복합니다.

## 버블 정렬 구현


``` js
	/**
	 * 버블 정렬 구현
	 * @param {Array} array
	 */
	function solution (array) {
		const unsorted_until_index = array.length - 1
		const result = [...array]
		let sorted = false

		while (!sorted) {
			sorted = true

			for (let i = 0; i < unsorted_until_index; i++) {
				if (result[i] > result[i + 1]) { // 왼쪽값 > 오른쪽 값 일 경우 값을 swap
					sorted = false
					const right = result[i]
					const left = result[i + 1]
		
					result[i] = left
					result[i + 1] = right
				}
			}
		}
		return result
	}

	const list = [65, 55, 45, 35, 25, 10]
	solution(list)  // [10, 25, 35, 45, 55, 65]
```

## 버블 정렬의 효율성

버블 정렬 알고리즘에 포함된 단계는 두 종류입니다.

* **비교** : 어느 쪽이 더 큰지 두 수를 비교합니다.
* **교환** : 정렬하기 위해 두 수를 교환합니다.

위 예제의 **버블 정렬에서 비교가 일어나는 단계**는, 5 + 4 + 3 + 2 + 1 = **총 15 번의 비교 단계** 를 거칩니다.

좀 더 일반적으로 말하면 원소 N 개가 있을 때, 아래의 공식 만큼 비교를 수행합니다.

```
	(N - 1) + (N - 2) + (N - 3) + ... + 1 
```

위 예제의 **버블 정렬에서 교환(swap) 이 일어나는 단계** 를 살펴봅시다. 

배열이 내림차순으로(큰 수 >>> 작은 수 순서대로) 정렬된 최악의 시나리오일 경우, **비교할 때마다 교환**을 해야합니다.

이러한 최악의 시나리오에서는 비교 15 번, 교환 15 번 = 총 30 단계가 필요합니다
	

| 배열 원소 N 개 | 최대 단계 수 | N²   |
| -------------- | ------------ | ---- |
| 5              | 20           | 25   |
| 10             | 90           | 100  |
| 20             | 380          | 400  |
| 40             | 1560         | 1600 |
| 80             | 6320         | 6400 |

N 이 증가할 때마다 단계 수가 얼마씩 늘어나는지 정확히 살펴보면 대략 N² 만큼 늘어남을 알게됩니다.

따라서 빅 오 표기법에서는 버블 정렬의 효율성을 `O(N²)` 이라고 부릅니다.
 `O(N²)` 은 데이터가 증가할 때 단계 수가 급격히 늘어나므로 비교적 비효율적인 알고리즘으로 간주됩니다.

 
<img src="https://res.cloudinary.com/practicaldev/image/fetch/s--q9gaD0m_--/c_imagga_scale,f_auto,fl_progressive,h_900,q_auto,w_1600/https://thepracticaldev.s3.amazonaws.com/i/3ms2d5rfv25a2swyz1vs.png" width=500>

| 빅 오 표기법 | 단계 수                                       | 시간      | 사용 예제 |
| ------------ | --------------------------------------------- | --------- | --------- |
| `O(1)`       | 배열의 수와 상관없이 단계 수가 항상 한 단계   | 상수 시간 | 배열 읽기 |
| `O(N)`       | 배열의 수 만큼의 단계가 필요                  | 선형 시간 | 선형 검색 |
| `O(log N)`   | 배열이 두 배로 증가할 때마다 한 단계씩 늘어남 |           | 이진 검색 |
| `O(N²)`      | 배열이 늘어날 수록 단계 수가 제곱씩 늘어남    | 이차 시간 | 버블 정렬 |

## 이차 문제

``` js
	function hasDuplicateValue (array) {
		let steps = 0
		for (let i = 0; i < array.length; i++) {
			for (let j = 0; j < array.length; j++) {
				steps++
				if (i !== j && array[i] === array[j]) {
					return true
				}
			}
		}
		console.log(steps) // 총 9 단계가 걸린다
		return false
	}

	hasDuplicateValue([ 1, 2, 3 ])
```

배열에 중복 값이 있는지 확인할 때, 일반적으로 중첩 `for loop` 를 사용한다. 물론 잘 동작하는 코드이지만, 빅 오 표기법으로 효율성을 따져보았을 때 해당 코드는 `O(N²)` 알고리즘입니다.

 `O(N²)` 알고리즘은 상대적으로 느린 알고리즘으로 간주대기 때문에, 중첩 루프를 사용할 때는 더 빠른 대안은 없을지 생각할 필요가 있습니다. (없을 수도 있지만..)

 ## 선형 해결법
 
``` js
	function hasDuplicateValue (array) {
		let steps = 0
		const checkedVal = []

		for (let i = 0; i < array.length; i++) {
			steps ++
			const currVal = array[i]

			// 찾았던 값을 checkedVal에 기록한다.
			if (checkedVal[currVal] === undefined) checkedVal[currVal] = 1
			else return true
		}

		console.log(steps)			// 3
		console.log(checkedVal) // [ , , , 1, , 1, , , 1 ]
		return false
	}

	hasDuplicateValue([ 3, 5, 8 ])
```
> 루프가 하나이며, 찾았던 값을 `checkedVal` 에 기록해둡니다.
> 
> 코드가 새로운 수를 찾을 때마다 이 수에 맞는 `checkedVal` 배열의 인덱스에 값 1 을 저장하는 방법입니다.
> 단계 (`steps`) 를 확인해보면 3단계, 즉 배열의 원소 수와 같습니다. 이 구현법은 빅 오 표기법으로 `O(N)` 입니다.
> 
> `O(N²)` 보다  `O(N)` 이 훨씬 효율적 이라는 것을 이전에 배웠습니다.

위 예제 처럼 중복 루프를 쓰지 않는 함수를 구현해볼 수도 있습니다.


## 마무리

빅 오 표기법을 명확히 이해하면 느린 코드를 식별해 내고 두 경쟁 알고리즘 중 더 빠른 알고리즘을 분명하게 골라낼 수 있습니다.