- [빅 오로 코드 속도 올리기](#빅-오로-코드-속도-올리기)
	- [버블 정렬](#버블-정렬)
	- [버블 정렬 구현](#버블-정렬-구현)
	- [버블 정렬의 효율성](#버블-정렬의-효율성)

# 빅 오로 코드 속도 올리기

일상적으로 프로그래머는 작성하는 코드에서도 선형검색, 이진 검색 두가지가 바로 떠오르는 것이 아니라,
가장 먼저 떠오른 방법을 시도할 가능성이 높습니다. 빅 오를 사용하면 내가 만든 알고리즘과 범용 알고리즘을 비교할 기회가 생기며 "이 알고리즘이 일반적으로 사용되는 알고리즘만큼 빠른가/느린가" 를 확인해 볼 수 있습니다.

빅 오에서 내가 만든 알고리즘을 "느린" 알고리즘이라고 생각한다면 최적화하는 방법을 찾아 볼 수 있습니다. 

## 버블 정렬

*정렬 알고리즘* 은 컴퓨터 과항 분야에서 폭넓게 연구된 주제이며, 지난 수년간 수십 개의 정렬 알고리즘이 개발되어 왔습니다. 
```
	정렬되지 않은 배열이 주어졌을 때, 어떻게 오름차순으로 정렬할 수 있을까?
```

*단순 정렬*(simple sort) 알고리즘은, 이해하기 쉽지만, 더 빠르다고 알려진 정렬 알고리즘보다 비효율적 입니다.

*버블 정렬* 은 매우 기본적인 알고리즘은 다음과 같은 단계를 밟습니다.

1. 배열 내에서 연속된 두 항목을 선택하여 비교합니다. (처음에는 0, 1 번째 요소를 가리킵니다)
2. 왼쪽 값이 오른쪽 값보다 크면 두 항목을 교환(swap) 합니다. (순서가 올바르다면 2단계에선 아무것도 하지 않습니다.)
3. 포인터를 오른쪽으로 한 셀씩 옮깁니다. (1, 2 요소를 가리킵니다)
   > 배열의 끝 까지, 또는 이미 정렬된 어떤 항목까지 1 단계 2 단계를 반복합니다.
4. 더 이상 교환하지 않을 때 까지 1 단계부터 3 단계를 반복합니다.
   > 더는 교환을 하지 않는다는 것은 배열이 정렬된 상태라는 의미 입니다.

버블 정렬에서 1 단부터 3 단계 까지 반복하는 것을 *패스 스루*(passthrough) 라고 부릅니다. 알고리즘의 주요 단계들을 **통과** 했다는 의미이며, 완전히 정렬될 때 까지 같은 절차를 반복합니다.

## 버블 정렬 구현


``` js
	/**
	 * 버블 정렬 구현
	 * @param {Array} array
	 */
	function solution (array) {
		const unsorted_until_index = array.length - 1
		const result = [...array]
		let sorted = false

		while (!sorted) {
			sorted = true

			for (let i = 0; i < unsorted_until_index; i++) {
				if (result[i] > result[i + 1]) { // 왼쪽값 > 오른쪽 값 일 경우 값을 swap
					sorted = false
					const right = result[i]
					const left = result[i + 1]
		
					result[i] = left
					result[i + 1] = right
				}
			}
		}
		return result
	}

	const list = [65, 55, 45, 35, 25, 10]
	solution(list)  // [10, 25, 35, 45, 55, 65]
```

## 버블 정렬의 효율성