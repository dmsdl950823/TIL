# 긍정적인 시나리오 최적화

가장 자주 접할 수 있는 상황, 그러니까 최악의 상황이 아닌 경우, 모든 시나리오를 고려할 수 있는 능력은 어떤 상황에서든 적절한 알고리즘을 고를 수 있게 해주는 중요한 능력입니다.

## 삽입 정렬

*삽입 정렬*의 수행 순서는 다음과 같습니다. 

1. 첫 번째 패스스루에서 임시로 `index 1` (1 번째 셀) 을 임시 변수에 저장 후 삭제합니다. 이 인덱스에 값이 없으므로 공백이 생깁니다. 
 	> 이후 각 패스스루마다 다음 인덱스의 값을 삭제합니다.
2. 다음으로 공백 왼쪽에 있는 값을 가져와 임시 변수에 있는 값과 비교하는 시프트 단계를 시작합니다.
   > 공백 왼쪽에 있는 값이 임시 변수에 있는 값보다 크면 그 값을 오른쪽으로 시프트합니다.
	 > 자연히 공백은 왼쪽으로 옮겨지고, 임시로 삭제한 값보다 작은 값을 만나거나 배열의 왼쪽 끝에 도달해야 시프트 단계가 끝납니다.
3. 이제 임시로 제거한 값을 현재 공백에 삽입합니다.
4. 배열이 완전히 정렬될 때 까지 1 ~ 3 단계를 반복합니다.

## 삽입 정렬 구현

``` js
	function insertSort (array) {
		for (let i = 1; i < array.length; i++) { // index 1 부터 전체 배열을 순회하는 루프
			let position = i
			let tempVal = array[i] // 현재 index 및 임시 변수 를 저장합니다.

			// position 의 왼쪽에 있는 값이 tempVal 보다 큰 지 확인합니다.
			while (position > 0 && array[position - 1] > tempVal) {
				array[position] = array[position - 1]
				position = position - 1
				// 왼쪽 값을 한 셀 오른쪽으로 옮긴 후 position 값을 1 감소시킵니다.
				// 새 position 의 왼쪽 값이 tempVal 보다 큰지 확인하고 tempVal 보다 작은 값을 찾을 때 까지
				// 이 과정을 반복합니다.
			}

			// tempVal 을 공백에 삽입합니다.
			array[position] = tempVal
		}

		return array
	}

	const array = [4, 2, 7, 1, 3]
	insertSort(array)  // [ 1, 2, 3, 4, 7 ]
```

## 삽입 정렬의 효율성

삽입 정렬에 포함된 단계는, 삭제, 비교, 시프트, 삽입 이렇게 총 네 종류입니다. 삽입 정렬의 효율성을 분석하려면 각 단계별 총합을 계산해야합니다.

| 단계       |                                           | 총 단계 계산                                            |
| ---------- | ----------------------------------------- | ------------------------------------------------------- |
| **비교**   | 각 패스스루 에서 왼쪽 공백 갯수만큼 계산  | 1 + 2 + 3 + ... N - 1 번의 비교 => **N² / 2 번의 비교** |
| **시프트** | 값을 한 셀 오른쪽으로 옮길 때 마다 일어남 | 비교 횟수만큼 시프트가 일어남 => **N² / 2 번의 시프트** |
| **삭제**   | 각 패스스루당 한번                        | N - 1 번                                                |
| **삽입**   | 각 패스스루당 한번                        | N - 1 번                                                |
|            |                                           | **총 N² + 2N - 2 단계**                                 |

앞서 배웠드스이 빅 오에는 상수를 무시한다는 규칙이 있으므로, `O(N² + N)` 으로 단순화 시킬 수 있다.

``` 
	빅 오 표기법에는 가장 높은 차수의 N 만 고려한다
```

다시말해, N⁴ + N³ + N² + N 단계가 걸리는 알고리즘이 있을 때 N⁴ 만 중요하게 여기며 `O(N⁴)` 이라 부릅니다.

| N     | N²        | N³            | N⁴              |
| ----- | --------- | ------------- | --------------- |
| 2     | 4         | 8             | 16              |
| 5     | 25        | 125           | 625             |
| 10    | 100       | 1,000         | 10,000          |
| 100   | 10,000    | 1,000,000     | 100,000,000     |
| 1,000 | 1,000,000 | 1,000,000,000 | 100,000,000,000 |

N 이 증가할 수록 N 보다 N⁴ 이 더 크고 무거워집니다. 이러한 이유로 가장 큰 N 차수만 고려합니다.

따라서 `O(N² + N)` 은 단순히 `O(N²)` 이 됩니다.

결론적으로, 최악의 시나리오에서 *삽입정렬*은 *버블정렬* 이나 *선택정렬* 과 시간 복잡도가 같습니다. 셋 모두 `O(N²)` 입니다.

버블 정렬은 N² 단계이지만 선택 정렬은 N² / 2 였으며, 둘 다 빅 오 표기법에선 `O(N²)` 로 표기되었었습니다. 삽입 정렬 역시 실제로는 N² + 2N - 2 단계이지만 빅 오로는 `O(N²)` 단계가 걸리므로 언뜻 보기에는 버블정렬만큼 느리다고 볼 수 있겠습니다만, 사실은 더 복잡합니다.

## 평균적인 경우

가장 자주 일어나는 경우가 **평균 시나리오** 이다. 최악/최선의 시나리오는 드물게 일어난다.

데이터가 임의로 정렬된 경우에는 모든 데이터 / 일부 데이터를 비교하고 시프트하거나, 어떤 데이터도 비교하지 않거나 시프트하지 않는 패스스루도 있을 수 있습니다. 

최악의 시나리오에서는 **모든 데이터를 비교, 시프트** 하고, 최선의 시나리오에서는 패스스루당 한 번의 비교만 있을 뿐 **어떤 데이터도 시프트하지 않지만**, 평균 시나리오에서는 대체적으로 **데이터의 반을 비교** 하고 시프트할 것 입니다.

따라서 삽입 정렬의 최악의 시나리오에서 N² 단계가 걸린다면 평균 시나리오에선 N² / 2 단계가 걸린다고 볼 수 있습니다.


예제 배열 `[1, 2, 3, 4]`
| 삽입정렬      | 총 단계                                  |         |
| ------------- | ---------------------------------------- | ------- |
| 최악의 경우   | 6 번의 비교 + 6 번의 시프트 = 총 12 단계 | N² 단계 |
| 평균적인 경우 | 4 번의 비교 + 2 번의 시프트 = 총 6 단계  | N² / 2  |
| 최선의 경우   | 3 번의 비교 + 0 번의 시프트 = 총 3 단계  | N 단계  |

이렇게 서로 다른 이유는,
* 어떤 패스스루에서는 `tempVal` 왼쪽의 모든 데이터를 비교하지만,
* 어떤 패스스루에서는 `tempVal` 보다 작은 값을 만나면서 패스스루가 일찍 종료되기 때문입니다.

그렇다면 선택정렬과 삽입정렬중 어떤게 더 좋은 방법일까요?

정답은... 경우에 따라 다릅니다. 임의로 정렬된 배열 같은 평균적인 경우라면 두 정렬은 유사하게 수행됩니다.

거의 **정렬된 데이터**를 다룬다고 확신한다면 삽입정렬, **역순으로 정렬된 데이터**를 다룰 경우 선택정렬 이 더 빠릅니다. 데이터가 어떨지 전혀 알 수 없다면 기본적으로 **평균적인 경우**이며, 둘 다 같습니다.


## 실제 예제

두 배열의 교집합을 구하는 JS 예제입니다.

``` js
	function solution (arr1, arr2) {
		const result = []
		let step = 0

		for (let i = 0; i < arr1.length; i++) {
			for (let j = 0; j < arr2.length; j++) {
				step ++
				if (arr1[i] === arr2[j]) {
					result.push(arr1[i])
				}
			}
		}

		console.log(step) // 16 단계
		return result
	}

	const array1 = [3, 1, 4, 2]
	const array2 = [4, 5, 3, 6]

	solution(array1, array2) // [3, 4]
```

이 알고리즘을 향상시킬 수 있는 방법은 없을까?

바로 지금이 최악의 경우를 넘어 다른 시나리오를 고려해 봐야 하는 시점입니다.

이 예제에서, 공통된 값을 찾은 후에는 이후의 비교를 수행할 필요가 없습니다. 그러므로 `break` 만 추가하여 중복된 값을 찾으면 이후에 불필요한 비교를 중단합니다.

아래 코드처럼 고칠 수 있습니다.

``` js
	function solution (arr1, arr2) {
		const result = []
		let step = 0

		for (let i = 0; i < arr1.length; i++) {
			for (let j = 0; j < arr2.length; j++) {
				step ++
				if (arr1[i] === arr2[j]) {
					result.push(arr1[i])
					break
				}
			}
		}

		console.log(step) // 12 단계로 줄일 수 있습니다
		return result
	}

	const array1 = [3, 1, 4, 2]
	const array2 = [4, 5, 3, 6]

	solution(array1, array2) // [3, 4]
```

## 마무리

최선, 평균, 최악의 시나리오를 구분하는 능력은 기존 알고리즘을 최적화해서 훨씬 빠르게 만드는 것 만큼이나 사용자 요구에 맞는 최적의 알고리즘을 고르는 핵심기술입니다. 최악의 경우를 대비하는 것도 좋지만, 대부분은 평균적인 경우가 일어난다는 점을 명심해야합니다.
