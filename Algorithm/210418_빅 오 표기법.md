- [빅 오(Big O) 표기법](#빅-오big-o-표기법)
	- [단계 수 계산](#단계-수-계산)
	- [상수 시간과 선형 시간](#상수-시간과-선형-시간)
	- [같은 알고리즘, 다른 시나리오](#같은-알고리즘-다른-시나리오)
	- [`O(log N)` 세 번째 유형의 알고리즘](#olog-n-세-번째-유형의-알고리즘)
	- [로가리즘](#로가리즘)
	- [`O(log N)` 해석](#olog-n-해석)

# 빅 오(Big O) 표기법

컴퓨터 과학자는 서로 간에 시간 복잡도를 쉽게 소통할 목적을 자료 구조와 알고리즘의 효율성을 간결하고 일관된 언어로 설명하기 위해 수학적 개념을 차용했습니다. 이러한 개념을 형식화한 표현을 *빅 오(Big O) 표기법* 이라고 부르며, 빅 오 표기법을 사용하여 **주어진 알고리즘의 효율성을 쉽게 분류하고 이해**시킬 수 있습니다.

빅 오 표기법을 알면 일관되고 간결한 방법으로 어떤 알고리즘이든 분석할 수 있는 도구가 생깁니다. 참고로 수학에서 유래하지만, 컴퓨터 과학에서도 사용합니다.

## 단계 수 계산
빅 오는 시간 단위가 아닌 **알고리즘에 필요한 단계 수 만을 고려**함으로써 일관성을 유지합니다.

[배열 읽기에 필요한 단계 수](./210412_자료구조가%20중요한%20이유.md/#읽기) 는 배열의 크기와 상관없이 딱 한 개였는데, 빅 오 표기법으로 표현하면 `O(1)` 로 표기됩니다.

일반적으로 "빅 오 1" 또는 "차수 1" 이라고 부릅니다.

[선형 검색에 필요한 단계 수](./210412_자료구조가%20중요한%20이유.md/#검색) 는, 한 번에 한 셀식 확인하여 배열에 특정 값을 검색했는데, 최대 N 단계 까지 걸릴 수 있으므로 `O(N)` 로 표기됩니다.

```
	# tip - 빅 오의 수학적 설명
		빅 오는 원래 수학 개념이므로 수학 용어로 설명되곤 합니다.
```

## 상수 시간과 선형 시간

빅 오 표기법은 알고리즘에 걸리는 단계 수를 데이터 원소 수를 이용하여 간단하게 표현합니다. 다시 말해 빅 오는 **데이터가 증가할 수록 단계 수는 어떻게 변하는가?** 에 대한 결론을 줄 수 있습니다.

<img src="https://res.cloudinary.com/practicaldev/image/fetch/s--q9gaD0m_--/c_imagga_scale,f_auto,fl_progressive,h_900,q_auto,w_1600/https://thepracticaldev.s3.amazonaws.com/i/3ms2d5rfv25a2swyz1vs.png" width=500>

| 빅 오 표기법 | 단계 수                                       | 시간      | 사용 예제 |
| ------------ | --------------------------------------------- | --------- | --------- |
| `O(1)`       | 배열의 수와 상관없이 단계 수가 항상 한 단계   | 상수 시간 | 배열 읽기 |
| `O(N)`       | 배열의 수 만큼의 단계가 필요                  | 선형 시간 | 선형 검색 |
| `O(log N)`   | 배열이 두 배로 증가할 때마다 한 단계씩 늘어남 |           | 이진 검색 |


## 같은 알고리즘, 다른 시나리오

* 원하던 항목을 한 단계만에 찾은 경우, **최선** 의 시나리오에선 `O(1)`,
* 그렇지 않고 모든 배열에서 찾아야 하는 경우, **최악** 의 시나리오에선 `O(N)` 이 걸립니다.

별도로 명시하지 않는 한 빅 오 표기법은 일반적으로 최악의 시나리오를 의미합니다.

이것은 일반적으로 **비관적인** 접근이 유용한 도구이기 때문입니다.

최악의 시나리오에서 사용하고있는 알고리즘이 얼마나 비효율적인지 정확히 알면 최악을 대비함과 동시에 알고리즘의 선택에 중요한 영향을 미칠 수 있습니다.

## `O(log N)` 세 번째 유형의 알고리즘

빅 오 표기법의 관점에서는 *이진 검색*을 `O(N)` `O(N)` 사이 어디쯤으로 보는, `O(log N)` 으로 표기하고 "오 로그"라고 읽습니다.

간단히 말해 `O(log N)` 은 **데이터가 두 배로 증가할 때마다 한 단계씩 늘어나는 알고리즘** 을 설명하는 빅 오 표기 방식입니다.

`O(1)` 보다는 덜 효율적이지만 `O(N)` 보다는 훨씬 효율적인데, `O(log N)` 을 이해하기 위해서는 *로가리즘* 이라는 수학적 개념을 먼저 이해해야합니다.

## 로가리즘

log 란 *로가리즘* 의 줄임말 입니다. 사실 로가리즘과 알고리즘이 매우 비슷하게 발음되고, 비슷하게 보이지만 두 단어는 아무 관련이 없습니다. (!!!)

로가리즘은 **지수** 와 **역**(inverse) 의 관계입니다.

```
	# 일반적인 수학 정의
	# log₂8 은 2³ 의 역 (2 를 몇 번 곱해야 8을 얻을 수 있는지를 의미)
	2³ === 2 * 2 * 2 === 8
	log₂8 = 3  
	
	2 * 2 * 2 * 2 * 2 * 2 = 64
	log₂64 = 6
```

```
	# 로가리즘을 조금 더 쉬운 방식으로 설명하는 경우
	# 1 이 될 때 까지 8을 2로 3번 나눈다.
	8 / 2 / 2 / 2 = 1 
	log₂8 = 3

	# 1 이 될 때 까지 64를 2로 6번 나눈다
	64 / 2 / 2 / 2 / 2 / 2 / 2 = 1
	log₂64 = 6
```


## `O(log N)` 해석

`O(log N)` 은 `O(log₂ N)` 의 밑₂ 를 생략하여 표기된 것인데, 
`O(log N)` 은 데이터 원소가 N 개 있으면 알고리즘에서 `log₂N` 단계가 걸린다는 의미입니다.

예를들어 배열이 총 8개라면 `log₂8 = 3` 이므로 알고리즘은 총 3 단계가 걸립니다.

이진 검색은 이렇게 동작한다. 특정 항목을 찾을 때 값이 **한 개가 될 때 까지 데이터 원소를 계속해서 반으로 줄이는 만큼의 단계 수**가 걸린다는 의미입다.

| 배열 개수(N) | O(N) | O(log N) |
| ------------ | ---- | -------- |
| 8            | 8    | 3        |
| 16           | 16   | 4        |
| 32           | 32   | 5        |
| 64           | 64   | 6        |
| 128          | 128  | 7        |
| 256          | 256  | 8        |
| 512          | 512  | 9        |
| 1024         | 1024 | 10       |

`O(N)` 알고리즘이 데이터 원소 수 만큼의 단계가 필요한 반면, `O(log N)` 는 데이터 원소가 두 배로 늘어날 때 마다 딱 한계 씩만 더 필요합니다. 



