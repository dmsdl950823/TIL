- [스택과 큐](#스택과-큐)
	- [스택](#스택)
		- [스택 다뤄보기](#스택-다뤄보기)

# 스택과 큐

지금끼지는 연산의 **성능**이 어떻게 달라지는가에 초점을 맞추었지만, 다양한 자료구조를 알면 간단하고 읽기 쉬운 코드를 생성하는데 도움이 됩니다.

스택과 큐는 비슷한데, 제약을 갖는 배열입니다. 이 제약 덕분에 두 자료구조가 매우 간결해집니다.

간단하게, 스택과 큐는 임시 데이터를 처리할 수 있는 간결한 도구입니다. 스택과 큐를 임시 데이터로 사용하여 뛰어난 알고리즘을 만들 수 있습니다.

예시로, 식당에서는 주문이 들어온 순서대로 식사를 만들어야합니다. 주문한 내역은 식사를 준비해서 배달할 때까지만 중요하고, 이후에는 버려집니다. 스택과 큐를 사용하면 데이터를 순차적으로 처리하고, 필요없으면 버립니다.

## 스택

<img src="https://cb.scene7.com/is/image/Crate/EssentialDinnerPlt10p5inS8SSS20" width=300>

> 산처럼 쌓여있는 설거지거리 접시들을 생각해 볼 수 있는데, 가장 위를 제외하고는 접시를 추가/제거할 수 없습니다.

*스택* (stack) 이 데이터를 저장하는 방법은 배열과 같습니다. (단순한 원소들의 리스트) 스택에는 다음과 같은 제약이 있습니다.

```
	* 데이터는 스택의 끝에만 삽입
	* 데이터는 스택의 끝에서 읽기
	* 데이터는 스택의 끝에서 삭제
```


* 스택의 끝을 **위**(top), 스택의 시작을 **밑**(bottom) 이라고 합니다.
* 스택에 새 값을 **삽입**하는 것을 **스택에 푸시** 한다고 말합니다.
* 스택의 위에서 값을 **제거**하는 것을 **스택으로부터 팝** 한다고 말합니다.
  
스택 연산을 묘사하는데 쓰이는 유용한 두문자어가 "Last in, First Out" (LIFO) 입니다. 스택에 추가된 마지막 항목이 제일먼저 스택에서 제거될 것이라는 의미입니다. 


### 스택 다뤄보기

일반적으로 스택은 임시데이터를 다뤄야하는 알고리즘에서 유용합니다.

예제는 자바스크립트 코드를 검사하는 Linter 프로그램을 만들어봅니다. 소괄호, 중괄호, 대괄호에 문법적 오류가 있는 경우 동작합니다.

| 문법 오류 종류          | 설명                                         |
| ----------------------- | -------------------------------------------- |
| `(const x = 2`          | 닫는 `)` 괄호가 없을때                       |
| `const x = 2)`          | 여는 `(` 괄호가 없을때                       |
| `(const x = [1, 2, 3)]` | 여는 괄호와 닫는괄호가 서로 일치하지 않을 때 |

이럴 때 스택을 사용하여 알고리즘을 구할 수 있습니다.

1. 괄호가 아닌 모든 문자는 무시하고 넘어갑니다.
2. 여는 괄호(`(`, `{`, `[`) 가 나오면 **스택에 푸시**합니다. 스택에 넣는다는 것은 이 괄호가 닫히기를 기다린다는 것 입니다.
3. 닫는 괄호(`)`, `}`, `]`) 가 나오면 스택을 확인합니다.
   * 스택에 원소가 없으면 닫는 괄호에 대응하는 여는 괄호가 이전에 나오지 않은 것 (문법오류 2번)
   * 스택에 있지만, 닫는 괄호가 스택 위에 있는 원소와 괄호 종류가 다를 경우 (문법오류 3)
   * 닫는 괄호가 스택에 있는 여는 괄호와 일치하면 스택의 원소를 팝합니다.
4. 스택이 여전히 남아있는 괄호가 있다면 여는 괄호에 대응하는 닫는 괄호가 없다는 의미입니다 (문법오류 4)

``` js
	function linter (text) {
		const stack = [] // 간단한 배열을 스택으로 사용
		
		const openBracket = letter => ['(', '{', '['].includes(letter)
		const closeBracket = letter => [')', '}', ']'].includes(letter)
		const openingBracketOf = letter => {
			return { ')': '(', '}': '{', ']': '[' }[letter]
		}
		// const recentOpeningBracket = stack.last
		const closeOpeningBracket = letter => openBracket(letter) === closeBracket(letter)


		for (const t of text) {

			// 여는 괄호면
			if (openBracket(t)) stack.push(t) // 스택에 푸시

			// 닫는 괄호면
			else if (closeBracket(t)) {

				if (closeOpeningBracket(t)) { // 가장 최근에 나온 여는 괄호를 닫은 경우
					console.log(111)
					stack.pop(t) // 스택에서 해당 여는 괄호 팝
				}

			}
		}

		console.log(stack)
	}

	const ex = '(var x = {y: [1, 2, 3}])'
	linter(ex)
```